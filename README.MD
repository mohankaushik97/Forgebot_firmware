# Encoder & Motor Wiring Guide

## Encoder Readings

- **Clockwise Rotation:** `S1 â†’ S2`  
- **Anti-Clockwise Rotation:** `S2 â†’ S1`

**Logic Table:**

| Event           | Condition       | Direction     |
|-----------------|-----------------|---------------|
| `S1` Triggered  | `S2 = LOW`      | Clockwise     |
| `S1` Triggered  | `S2 = HIGH`     | Anti-Clockwise|

---

## Motor Wiring

| Motor Wire | Connection | Note |
|------------|------------|------|
| **Red (M-)**  | OUT1       |      |
| **Black (M+)**| OUT2       |      |

**Direction Control:**

| OUT1 | OUT2 | Direction  |
|------|------|-------------|
| LOW  | HIGH | Clockwise   |

---

## Encoder Pinout

| Encoder Wire | Connection | Function |
|--------------|------------|----------|
| **White**    | VCC        | Power    |
| **Yellow**   | GND        | Ground   |
| **Orange**   | S1 (ENCA)  | Channel A|
| **Green**    | S2 (ENCB)  | Channel B|

---

## Library capabilities

| Library          | Level              | Function                              |
|------------------|--------------------|---------------------------------------|
| **MotorDriver**  | Single Motor       | Control â€” Speed, Direction            |
| **MotorEncoder** | Single Motor       | Measure â€” Speed, Direction            |
| **PIDController**| Single Motor       | Closed-loop â€” Position, Velocity      |
| **Kinematics**   | Motor Integration  | Robot â€” Position, Velocity            |
| **Communication**| micro-ROS Integration | Input â€” Velocity, Output â€” Position |

---
---

# MotorDriver Class - Function Reference

| Function | Parameters | Description | Returns |
|----------|------------|-------------|---------|
| `MotorDriver()` | â€” | Default constructor | â€” |
| `MotorDriver(uint8_t in1Pin, uint8_t in2Pin)` | `in1Pin`, `in2Pin` | Constructor with motor pins | â€” |
| `MotorDriver(uint8_t in1Pin, uint8_t in2Pin, uint8_t enAPin, uint8_t enBPin)` | `in1Pin`, `in2Pin`, `enAPin`, `enBPin` | Constructor with motor and encoder pins | â€” |
| `bool init()` | â€” | Initialize the DRV8833 motor driver. Default decay mode: SLOW. | `true` if no error occurs |
| `bool move(float power, int dir)` | `power` (-100..100), `dir` | Set motor rotation speed and direction. Negative = reverse, positive = forward, zero = stop. Uses fast decay for smooth movement. | `true` if no error occurs |
| `bool stop()` | â€” | Stop the motor using fast decay mode | `true` if no error occurs |
| `bool brake()` | â€” | Stop the motor using slow decay mode | `true` if no error occurs |
| `void setFrequency(uint32_t frequency)` | `frequency` (1..50000 Hz) | Set PWM frequency for ESP32 ledc | â€” |
| `void setChannel(uint8_t channel_)` | `channel_` | Set the PWM channel | â€” |
| `void setSwapDirection(bool swapDirection)` | `swapDirection` | Swap motor rotation direction (useful for correcting cabling or controlling opposite wheels) | â€” |

---

# MotorEncoder Class - Function Reference

| Function | Parameters | Description | Returns |
|----------|------------|-------------|---------|
| `MotorEncoder(uint8_t pinA, uint8_t pinB)` | `pinA`, `pinB` | Constructor. Assigns encoder pins A and B | â€” |
| `void init()` | â€” | Initialize the encoder | â€” |
| `void measurePos()` | â€” | Measure and update the current position of the motor | â€” |
| `void setSwapDirection(bool swapDirection_)` | `swapDirection_` | Swap the encoder reading direction | â€” |
| `static void measurePosHandler()` | â€” | Static interrupt handler for position measurement | â€” |
| `tuple<bool, float, int> motorControl(int32_t target)` | `target` | Compute control signal to reach target position | Tuple: `(success, power, direction)` |
| `int32_t getPos()` | â€” | Get the current position of the motor | `pos` |
| `void printPos()` | â€” | Print the current position to Serial | â€” |
| `int8_t getEnA()` | â€” | Get the encoder pin A number | `enA` |

---

# Multi-Motor Robot Code Structure with PID (PlatformIO)

This document describes a recommended **PlatformIO project structure** for building a multi-motor robot with PID control. It separates hardware abstraction, control logic, and application orchestration for better scalability and maintainability.

---

## ðŸ“‚ Suggested Project Structure

```
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ config.h              # Pin mappings, constants
â”‚   â””â”€â”€ types.h               # Common typedefs/structs
â”‚
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ MotorDriver/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ MotorDriver.cpp
â”‚   â”‚   â”‚   â””â”€â”€ MotorDriver.h
â”‚   â”‚   â””â”€â”€ library.json      # Optional metadata
â”‚   â”‚
â”‚   â”œâ”€â”€ MotorEncoder/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ MotorEncoder.cpp
â”‚   â”‚   â”‚   â””â”€â”€ MotorEncoder.h
â”‚   â”‚   â””â”€â”€ library.json
â”‚   â”‚
â”‚   â”œâ”€â”€ PIDController/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ PID.cpp
â”‚   â”‚   â”‚   â””â”€â”€ PID.h
â”‚   â”‚   â””â”€â”€ library.json
â”‚   â”‚
â”‚   â”œâ”€â”€ Kinematics/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ Kinematics.cpp    # e.g. differential / omni calculations
â”‚   â”‚   â”‚   â””â”€â”€ Kinematics.h
â”‚   â”‚   â””â”€â”€ library.json
â”‚   â”‚
â”‚   â””â”€â”€ Communication/
â”‚       â”œâ”€â”€ src/
â”‚       â”‚   â”œâ”€â”€ Comms.cpp         # Serial, ROS, Wi-Fi comms
â”‚       â”‚   â””â”€â”€ Comms.h
â”‚       â””â”€â”€ library.json
â”‚
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.cpp               # Setup + main control loop
â”‚
â”œâ”€â”€ platformio.ini
â””â”€â”€ README.md
```

---

## ðŸ“Œ Responsibilities of Each Module

- **`MotorDriver`**: Low-level control of motor pins (PWM, direction).  
- **`MotorEncoder`**: Encoder tick counting, velocity, position.  
- **`PIDController`**: Generic PID implementation (can be reused for velocity, position, heading).  
- **`Kinematics`**: Translates robot-level commands (vx, vy, Ï‰) into per-wheel targets. Different drives (differential, omni, mecanum) live here.  
- **`Communication`**: Handles commands from RPi/ROS or serial console. Converts high-level velocity commands into setpoints for PID.  
- **`main.cpp`**: Only orchestrates:
  1. Init modules  
  2. Read sensors  
  3. Run control (PID, kinematics)  
  4. Send motor commands  
  5. Publish telemetry  

---

## ðŸ“„ Example `main.cpp` (skeleton)

```cpp
#include <Arduino.h>
#include "config.h"

#include <MotorDriver.h>
#include <MotorEncoder.h>
#include <PID.h>
#include <Kinematics.h>
#include <Comms.h>

// Four motors (omni or mecanum example)
MotorDriver motorFL(FL1, FL2, FL_PWM);
MotorDriver motorFR(FR1, FR2, FR_PWM);
MotorDriver motorBL(BL1, BL2, BL_PWM);
MotorDriver motorBR(BR1, BR2, BR_PWM);

MotorEncoder encFL(FL_A, FL_B);
MotorEncoder encFR(FR_A, FR_B);
MotorEncoder encBL(BL_A, BL_B);
MotorEncoder encBR(BR_A, BR_B);

PID pidFL(1.0, 0.01, 0.1); // Tune values
PID pidFR(1.0, 0.01, 0.1);
PID pidBL(1.0, 0.01, 0.1);
PID pidBR(1.0, 0.01, 0.1);

Kinematics kinematics(WHEEL_RADIUS, WHEEL_BASE, TRACK_WIDTH);
Comms comms;

void setup() {
    Serial.begin(115200);
    motorFL.init();
    motorFR.init();
    motorBL.init();
    motorBR.init();

    encFL.init();
    encFR.init();
    encBL.init();
    encBR.init();

    comms.init();
}

void loop() {
    // 1. Read encoders
    float velFL = encFL.getVelocity();
    float velFR = encFR.getVelocity();
    float velBL = encBL.getVelocity();
    float velBR = encBR.getVelocity();

    // 2. Get high-level command (e.g. from ROS: vx, vy, omega)
    RobotCommand cmd = comms.getCommand();

    // 3. Convert to wheel targets
    WheelVelocities targets = kinematics.inverse(cmd.vx, cmd.vy, cmd.omega);

    // 4. PID control per wheel
    float outFL = pidFL.compute(targets.fl, velFL);
    float outFR = pidFR.compute(targets.fr, velFR);
    float outBL = pidBL.compute(targets.bl, velBL);
    float outBR = pidBR.compute(targets.br, velBR);

    // 5. Send to motors
    motorFL.setPWM(outFL);
    motorFR.setPWM(outFR);
    motorBL.setPWM(outBL);
    motorBR.setPWM(outBR);

    // 6. Telemetry back
    comms.publishOdom(encFL.getPos(), encFR.getPos(), encBL.getPos(), encBR.getPos());
}
```

---

âœ… Benefits of this structure:
- **Scalable**: Add more drives (arms, turrets) without cluttering `main.cpp`.  
- **Reusable**: `PID` and `Kinematics` are generic.  
- **Testable**: Each module can be tested in isolation.  
- **Industry-like**: Mirrors ROS layering (drivers â†’ control â†’ kinematics â†’ comms).  

---
